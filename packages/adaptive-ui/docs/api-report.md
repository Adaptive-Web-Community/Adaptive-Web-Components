## API Report File for "@adaptive-web/adaptive-ui"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Color as Color_2 } from 'culori/fn';
import { CSSDesignToken } from '@microsoft/fast-foundation';
import { CSSDirective } from '@microsoft/fast-element';
import { DesignToken } from '@microsoft/fast-foundation';
import { DesignTokenResolver } from '@microsoft/fast-foundation';
import { ElementStyles } from '@microsoft/fast-element';
import { ValuesOf } from '@microsoft/fast-foundation';

// @public
export class BasePalette<T extends Swatch> implements Palette<T> {
    constructor(source: Color, swatches: ReadonlyArray<T>);
    readonly closestIndexCache: Map<number, number>;
    closestIndexOf(reference: RelativeLuminance): number;
    colorContrast(reference: RelativeLuminance, contrastTarget: number, initialSearchIndex?: number, direction?: PaletteDirection): T;
    delta(reference: RelativeLuminance, delta: number, direction: PaletteDirection): T;
    get(index: number): T;
    readonly lastIndex: number;
    readonly reversedSwatches: ReadonlyArray<T>;
    readonly source: Color;
    readonly swatches: ReadonlyArray<T>;
}

// @internal
export const _black: Swatch;

// @public
export function blackOrWhiteByContrast(reference: Swatch, minContrast: number, defaultBlack: boolean): Swatch;

// @public
export function blackOrWhiteByContrastSet(set: InteractiveSwatchSet, minContrast: number, defaultBlack: boolean): InteractiveSwatchSet;

// @public (undocumented)
export const BorderFill: {
    all: (value: StyleValue) => StyleProperties;
};

// @public (undocumented)
export const BorderStyle: {
    all: (value: StyleValue) => StyleProperties;
};

// @public (undocumented)
export const BorderThickness: {
    all: (value: StyleValue) => StyleProperties;
};

// @public
export class Color implements RelativeLuminance, CSSDirective {
    constructor(color: Color_2);
    readonly color: Color_2;
    contrast: any;
    createCSS: () => string;
    static from(obj: {
        r: number;
        g: number;
        b: number;
        alpha?: number;
    }): Color;
    static fromRgb(r: number, g: number, b: number, alpha?: number): Color;
    static parse(color: string): Color | undefined;
    get relativeLuminance(): number;
    toColorString(): string;
}

// @public
export type ColorRecipe<T = Swatch> = RecipeOptional<ColorRecipeParams, T>;

// @public
export type ColorRecipeBySet<T = Swatch> = Recipe<InteractiveSwatchSet, T>;

// @public
export type ColorRecipeBySetEvaluate<T = Swatch> = RecipeEvaluate<InteractiveSwatchSet, T>;

// @public
export type ColorRecipeEvaluate<T = Swatch> = RecipeEvaluateOptional<ColorRecipeParams, T>;

// @public
export type ColorRecipePalette<T = Swatch> = Recipe<ColorRecipePaletteParams, T>;

// @public
export type ColorRecipePaletteEvaluate<T = Swatch> = RecipeEvaluate<ColorRecipePaletteParams, T>;

// @public
export type ColorRecipePaletteParams = ColorRecipeParams & {
    palette: Palette;
};

// @public
export type ColorRecipeParams = {
    reference: Swatch | null;
};

// @public
export interface ComponentAnatomy<TConditions extends ComponentConditions, TParts extends ComponentParts> {
    conditions: TConditions;
    focus?: FocusDefinition<TParts>;
    interactivity?: InteractivityDefinition;
    parts: TParts;
}

// @public
export type ComponentConditions = Record<string, string>;

// @public
export type ComponentParts = Record<string, string>;

// @public
export function contrast(a: RelativeLuminance, b: RelativeLuminance): number;

// @public
export function contrastAndDeltaSwatchSet(palette: Palette, reference: Swatch, minContrast: number, restDelta: number, hoverDelta: number, activeDelta: number, focusDelta: number, disabledDelta: number, disabledPalette?: Palette, direction?: PaletteDirection, zeroAsTransparent?: boolean): InteractiveSwatchSet;

// @public
export function contrastSwatch(palette: Palette, reference: Swatch, minContrast: number, direction?: PaletteDirection): Swatch;

// @public (undocumented)
export const CornerRadius: {
    all: (value: StyleValue) => StyleProperties;
};

// Warning: (ae-internal-missing-underscore) The name "create" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export const create: typeof DesignToken.create;

// @public
export function createForegroundSet(foregroundRecipe: TypedDesignToken<InteractiveColorRecipe>, background: InteractiveTokenGroup<Swatch>): InteractiveTokenGroup<Swatch>;

// @public
export function createForegroundSetBySet(foregroundRecipe: TypedDesignToken<InteractiveColorRecipeBySet>, background: InteractiveTokenGroup<Swatch>): InteractiveTokenGroup<Swatch>;

// Warning: (ae-internal-missing-underscore) The name "createNonCss" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export function createNonCss<T>(name: string): DesignToken<T>;

// @public
export function createTokenColor(name: string, intendedFor?: StyleProperty | StyleProperty[]): TypedCSSDesignToken<string>;

// @public
export function createTokenColorRecipe<T = Swatch>(baseName: string, intendedFor: StyleProperty | StyleProperty[], evaluate: ColorRecipeEvaluate<T>): TypedDesignToken<ColorRecipe<T>>;

// @public
export function createTokenColorRecipeBySet<T = Swatch>(baseName: string, intendedFor: StyleProperty | StyleProperty[], evaluate: ColorRecipeBySetEvaluate<T>): TypedDesignToken<ColorRecipeBySet<T>>;

// @public
export function createTokenColorRecipeForPalette<T = Swatch>(baseName: string, intendedFor: StyleProperty | StyleProperty[], evaluate: ColorRecipePaletteEvaluate<T>): TypedDesignToken<ColorRecipePalette<T>>;

// @public
export function createTokenColorRecipeValue(recipeToken: TypedDesignToken<ColorRecipe<Swatch>>): TypedCSSDesignToken<Swatch>;

// @public
export function createTokenColorRecipeWithPalette<T>(recipeToken: TypedDesignToken<Recipe<ColorRecipePaletteParams, T>>, paletteToken: DesignToken<Palette>): TypedDesignToken<RecipeOptional<ColorRecipeParams, T>>;

// @public
export function createTokenColorSet(recipeToken: TypedDesignToken<InteractiveColorRecipe>): InteractiveTokenGroup<Swatch>;

// @public
export function createTokenDelta(baseName: string, state: keyof InteractiveSwatchSet, value: number | DesignToken<number>): TypedDesignToken<number>;

// @public
export function createTokenDimension(name: string, intendedFor?: StyleProperty | StyleProperty[]): TypedCSSDesignToken<string>;

// @public
export function createTokenFontFamily(name: string): TypedCSSDesignToken<string>;

// @public
export function createTokenFontSize(name: string): TypedCSSDesignToken<string>;

// @public
export function createTokenFontStyle(name: string): TypedCSSDesignToken<string>;

// @public
export function createTokenFontVariations(name: string): TypedCSSDesignToken<string>;

// @public
export function createTokenFontWeight(name: string): TypedCSSDesignToken<number>;

// @public
export function createTokenLineHeight(name: string): TypedCSSDesignToken<string>;

// @public
export function createTokenMinContrast(baseName: string, value: number | DesignToken<number>): TypedDesignToken<number>;

// @public
export function createTokenNonCss<T>(name: string, type: DesignTokenType, intendedFor?: StyleProperty | StyleProperty[]): TypedDesignToken<T>;

// @public
export function createTokenNumber(name: string, intendedFor?: StyleProperty | StyleProperty[]): TypedCSSDesignToken<number>;

// @public
export function createTokenRecipe<TParam, TResult>(baseName: string, intendedFor: StyleProperty | StyleProperty[], evaluate: RecipeEvaluate<TParam, TResult>): TypedDesignToken<Recipe<TParam, TResult>>;

// @public
export function createTokenSwatch(name: string, intendedFor?: StyleProperty | StyleProperty[]): TypedCSSDesignToken<Swatch>;

// @public
export const createTyped: typeof TypedCSSDesignToken.createTyped;

// @public
export function deltaSwatch(palette: Palette, reference: Swatch, delta: number, direction?: PaletteDirection): Swatch;

// @public
export function deltaSwatchSet(palette: Palette, reference: Swatch, restDelta: number, hoverDelta: number, activeDelta: number, focusDelta: number, disabledDelta?: number, disabledPalette?: Palette, direction?: PaletteDirection, zeroAsTransparent?: boolean): InteractiveSwatchSet;

// @public
export const densityAdjustmentUnits: TypedDesignToken<number>;

// @public
export class DensityPaddingAndGapTokenGroup implements TokenGroup {
    constructor(name: string, horizontalPaddingUnits: number, horizontalGapUnits: number, verticalPaddingUnits: number, verticalGapUnits: number);
    readonly horizontalGap: TypedCSSDesignToken<string>;
    readonly horizontalGapUnits: TypedDesignToken<number>;
    readonly horizontalPadding: TypedCSSDesignToken<string>;
    readonly horizontalPaddingUnits: TypedDesignToken<number>;
    // (undocumented)
    readonly name: string;
    readonly verticalGap: TypedCSSDesignToken<string>;
    readonly verticalGapUnits: TypedDesignToken<number>;
    readonly verticalPadding: TypedCSSDesignToken<string>;
    readonly verticalPaddingUnits: TypedDesignToken<number>;
}

// @public
export class DesignTokenMetadata {
    // (undocumented)
    protected init(type: DesignTokenType, intendedFor?: StyleProperty | StyleProperty[]): void;
    get intendedFor(): StyleProperty[] | undefined;
    protected set intendedFor(value: StyleProperty[] | undefined);
    get type(): DesignTokenType;
    protected set type(value: DesignTokenType);
}

// @public
export class DesignTokenMultiValue<T extends CSSDirective | string> extends Array<T> implements CSSDirective {
    // (undocumented)
    createCSS(): string;
}

// @public
export const DesignTokenType: {
    readonly color: "color";
    readonly dimension: "dimension";
    readonly fontFamily: "fontFamily";
    readonly fontWeight: "fontWeight";
    readonly duration: "duration";
    readonly cubicBezier: "cubicBezier";
    readonly number: "number";
    readonly strokeStyle: "strokeStyle";
    readonly border: "border";
    readonly transition: "transition";
    readonly shadow: "shadow";
    readonly gradient: "gradient";
    readonly typography: "typography";
    readonly fontStyle: "fontStyle";
    readonly fontVariations: "fontVariations";
    readonly palette: "palette";
    readonly recipe: "recipe";
    readonly string: "string";
};

// @public
export type DesignTokenType = ValuesOf<typeof DesignTokenType> | string;

// @public
export function directionByIsDark(color: RelativeLuminance): PaletteDirectionValue;

// @public
export class ElementStylesRenderer {
    constructor(styles: Styles);
    render(target: StyleModuleTarget, interactivity?: InteractivityDefinition): ElementStyles;
}

// @public
export type ElevationRecipe = Recipe<number, string>;

// @public
export type ElevationRecipeEvaluate = RecipeEvaluate<number, string>;

// @public (undocumented)
export const Fill: {
    backgroundAndForeground: (background: InteractiveTokenGroup<Swatch>, foregroundRecipe: TypedDesignToken<InteractiveColorRecipe>) => StyleProperties;
    backgroundAndForegroundBySet: (background: InteractiveTokenGroup<Swatch>, foregroundRecipe: TypedDesignToken<InteractiveColorRecipeBySet>) => StyleProperties;
    foregroundNonInteractiveWithDisabled: (foreground: TypedCSSDesignToken<Swatch>, disabled: TypedCSSDesignToken<Swatch>) => StyleProperties;
};

// @public
export const Focus: {
    readonly hostFocused: () => FocusDefinition<any>;
    readonly hostChildFocused: <TParts>(indicatorPart: keyof TParts & string) => FocusDefinition<TParts>;
    readonly partFocused: <TParts_1>(part: keyof TParts_1 & string) => FocusDefinition<TParts_1>;
    readonly partWithin: <TParts_2>(indicatorPart: keyof TParts_2 & string, focusablePart: keyof TParts_2 & string) => FocusDefinition<TParts_2>;
};

// @public
export interface FocusDefinition<TParts> {
    focusTarget: StyleModuleTarget;
    resetTarget: StyleModuleTarget;
}

// @public
export type FocusSelector = "focus" | "focus-visible" | "focus-within";

// @public
export function idealColorDeltaSwatchSet(palette: Palette, reference: Swatch, minContrast: number, idealColor: Color, restDelta: number, hoverDelta: number, activeDelta: number, focusDelta: number, disabledDelta: number, disabledPalette?: Palette, direction?: PaletteDirection): InteractiveSwatchSet;

// @public
export type InteractiveColorRecipe = ColorRecipe<InteractiveSwatchSet>;

// @public
export type InteractiveColorRecipeBySet = ColorRecipeBySet<InteractiveSwatchSet>;

// @public
export type InteractiveColorRecipeBySetEvaluate = ColorRecipeBySetEvaluate<InteractiveSwatchSet>;

// @public
export type InteractiveColorRecipeEvaluate = ColorRecipeEvaluate<InteractiveSwatchSet>;

// @public
export type InteractiveColorRecipePalette = ColorRecipePalette<InteractiveSwatchSet>;

// @public
export type InteractiveColorRecipePaletteEvaluate = ColorRecipePaletteEvaluate<InteractiveSwatchSet>;

// @public
export interface InteractiveSet<T> {
    active: T;
    disabled: T;
    focus: T;
    hover: T;
    rest: T;
}

// @public
export interface InteractiveSwatchSet extends InteractiveSet<Swatch | null> {
}

// @public
export function interactiveSwatchSetAsOverlay(set: InteractiveSwatchSet, reference: Swatch, asOverlay: boolean): InteractiveSwatchSet;

// @public
export interface InteractiveTokenGroup<T> extends TokenGroup, InteractiveSet<TypedCSSDesignToken<T>> {
}

// @public
export const Interactivity: {
    readonly disabledAttribute: InteractivityDefinition;
    readonly hrefAttribute: InteractivityDefinition;
    readonly always: InteractivityDefinition;
    readonly never: InteractivityDefinition;
};

// @public
export interface InteractivityDefinition {
    disabledSelector?: string;
    interactivitySelector?: string;
}

// @public
export function isDark(color: RelativeLuminance): boolean;

// @public
export function luminanceSwatch(luminance: number): Swatch;

// @public
export function makeSelector(params: StyleModuleEvaluateParameters, state?: StateSelector): string;

// @public (undocumented)
export const Padding: {
    all: (value: StyleValue) => StyleProperties;
    verticalHorizontal: (valueVertical: StyleValue, valueHorizontal: StyleValue) => StyleProperties;
};

// @public
export interface Palette<T extends Swatch = Swatch> {
    closestIndexOf(reference: RelativeLuminance): number;
    colorContrast(reference: RelativeLuminance, minContrast: number, initialIndex?: number, direction?: PaletteDirection): T;
    delta(reference: RelativeLuminance, delta: number, direction: PaletteDirection): T;
    get(index: number): T;
    readonly source: Color;
    readonly swatches: ReadonlyArray<T>;
}

// @public
export type PaletteDirection = PaletteDirectionValue | (() => PaletteDirectionValue);

// @public
export const PaletteDirectionValue: Readonly<{
    readonly darker: 1;
    readonly lighter: -1;
}>;

// @public
export type PaletteDirectionValue = typeof PaletteDirectionValue[keyof typeof PaletteDirectionValue];

// @public
export class PaletteOkhsl extends BasePalette<Swatch> {
    // (undocumented)
    static from(source: Color | string): PaletteOkhsl;
}

// @public
export class PaletteRGB extends BasePalette<Swatch> {
    static from(source: Swatch | string, options?: Partial<PaletteRGBOptions>): PaletteRGB;
}

// @public
export interface PaletteRGBOptions {
    preserveSource: boolean;
    stepContrast: number;
    stepContrastRamp: number;
}

// @public
export interface Recipe<TParam, TResult> {
    evaluate: RecipeEvaluate<TParam, TResult>;
}

// @public (undocumented)
export type RecipeEvaluate<TParam, TResult> = (resolver: DesignTokenResolver, params: TParam) => TResult;

// @public (undocumented)
export type RecipeEvaluateOptional<TParam, TResult> = (resolver: DesignTokenResolver, params?: TParam) => TResult;

// @public
export interface RecipeOptional<TParam, TResult> {
    evaluate: RecipeEvaluateOptional<TParam, TResult>;
}

// @public
export interface RelativeLuminance {
    readonly relativeLuminance: number;
}

// @public
export function resolvePaletteDirection(direction: PaletteDirection): PaletteDirectionValue;

// @public
export type StateSelector = "hover" | "active" | FocusSelector | "disabled";

// @public
export type StyleModuleEvaluateParameters = StyleModuleTarget & InteractivityDefinition;

// @public (undocumented)
export type StyleModules = Iterable<readonly [StyleModuleTarget, Styles]>;

// @public
export interface StyleModuleTarget {
    focusSelector?: FocusSelector;
    hostCondition?: string;
    // @beta
    ignoreInteractivity?: boolean;
    part?: string;
    partCondition?: string;
    stateOnHost?: boolean;
}

// @public
export type StyleProperties = Partial<Record<StyleProperty, StyleValue>>;

// @public
export type StylePropertiesMap = Map<StyleProperty, StyleValue>;

// @public
export const StyleProperty: {
    readonly backgroundFill: "backgroundFill";
    readonly foregroundFill: "foregroundFill";
    readonly borderFillTop: "borderFillTop";
    readonly borderFillRight: "borderFillRight";
    readonly borderFillBottom: "borderFillBottom";
    readonly borderFillLeft: "borderFillLeft";
    readonly borderThicknessTop: "borderThicknessTop";
    readonly borderThicknessRight: "borderThicknessRight";
    readonly borderThicknessBottom: "borderThicknessBottom";
    readonly borderThicknessLeft: "borderThicknessLeft";
    readonly borderStyleTop: "borderStyleTop";
    readonly borderStyleRight: "borderStyleRight";
    readonly borderStyleBottom: "borderStyleBottom";
    readonly borderStyleLeft: "borderStyleLeft";
    readonly cornerRadiusTopLeft: "cornerRadiusTopLeft";
    readonly cornerRadiusTopRight: "cornerRadiusTopRight";
    readonly cornerRadiusBottomRight: "cornerRadiusBottomRight";
    readonly cornerRadiusBottomLeft: "cornerRadiusBottomLeft";
    readonly fontFamily: "fontFamily";
    readonly fontSize: "fontSize";
    readonly fontWeight: "fontWeight";
    readonly fontStyle: "fontStyle";
    readonly fontVariationSettings: "fontVariationSettings";
    readonly letterSpacing: "letterSpacing";
    readonly lineHeight: "lineHeight";
    readonly paddingTop: "paddingTop";
    readonly paddingRight: "paddingRight";
    readonly paddingBottom: "paddingBottom";
    readonly paddingLeft: "paddingLeft";
    readonly gap: "gap";
    readonly height: "height";
    readonly width: "width";
    readonly layoutDirection: "layoutDirection";
    readonly opacity: "opacity";
    readonly cursor: "cursor";
    readonly outlineColor: "outlineColor";
    readonly outlineOffset: "outlineOffset";
    readonly outlineStyle: "outlineStyle";
    readonly outlineWidth: "outlineWidth";
    readonly shadow: "shadow";
};

// @public
export type StyleProperty = ValuesOf<typeof StyleProperty>;

// @public (undocumented)
export const stylePropertyBorderFillAll: ("borderFillTop" | "borderFillRight" | "borderFillBottom" | "borderFillLeft")[];

// @public (undocumented)
export const stylePropertyBorderStyleAll: ("borderStyleTop" | "borderStyleRight" | "borderStyleBottom" | "borderStyleLeft")[];

// @public (undocumented)
export const stylePropertyBorderThicknessAll: ("borderThicknessTop" | "borderThicknessRight" | "borderThicknessBottom" | "borderThicknessLeft")[];

// @public (undocumented)
export const stylePropertyCornerRadiusAll: ("cornerRadiusTopLeft" | "cornerRadiusTopRight" | "cornerRadiusBottomRight" | "cornerRadiusBottomLeft")[];

// @public (undocumented)
export const stylePropertyPaddingAll: ("paddingBottom" | "paddingLeft" | "paddingRight" | "paddingTop")[];

// @public
export class Styles {
    // (undocumented)
    appendComposed(styles: Styles): void;
    clearComposed(): void;
    static compose(styles: Styles[], properties?: StyleProperties, name?: string): Styles;
    get composed(): Styles[] | undefined;
    get effectiveProperties(): StylePropertiesMap;
    static fromProperties(properties: StyleProperties, name?: string): Styles;
    readonly name: string | undefined;
    get properties(): StylePropertiesMap | undefined;
    set properties(properties: StylePropertiesMap | undefined);
    // (undocumented)
    static Shared: Map<string, Styles>;
}

// @public
export type StyleValue = CSSDesignToken<any> | InteractiveSet<any | null> | CSSDirective | string;

// @public
export class Swatch extends Color {
    protected constructor(color: Color_2, intendedColor?: Swatch);
    static asOverlay(intendedColor: Swatch, reference: Swatch): Swatch;
    static from(obj: {
        r: number;
        g: number;
        b: number;
        alpha?: number;
    }): Swatch;
    static fromColor(color: Color): Swatch;
    static fromRgb(r: number, g: number, b: number, alpha?: number): Swatch;
    static parse(color: string): Swatch | undefined;
    get relativeLuminance(): number;
    toTransparent(alpha?: number): Swatch;
}

// @public
export function swatchAsOverlay(swatch: Swatch | null, reference: Swatch, asOverlay: boolean): Swatch | null;

// @public
export interface TokenGroup {
    intendedFor?: StyleProperty | StyleProperty[];
    name: string;
    type?: DesignTokenType;
}

// Warning: (ae-different-release-tags) This symbol has another declaration with a different release tag
// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "TypedCSSDesignToken" because one of its declarations is marked as @internal
//
// @public
export class TypedCSSDesignToken<T> extends CSSDesignToken<T> implements DesignTokenMetadata {
    constructor(name: string, type: DesignTokenType, intendedFor?: StyleProperty | StyleProperty[]);
    static createTyped<T>(name: string, type: DesignTokenType, intendedFor?: StyleProperty | StyleProperty[]): TypedCSSDesignToken<T>;
}

// @internal (undocumented)
export interface TypedCSSDesignToken<T> extends DesignTokenMetadata {
}

// Warning: (ae-different-release-tags) This symbol has another declaration with a different release tag
// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "TypedDesignToken" because one of its declarations is marked as @internal
//
// @public
export class TypedDesignToken<T> extends DesignToken<T> implements DesignTokenMetadata {
    constructor(name: string, type: DesignTokenType, intendedFor?: StyleProperty | StyleProperty[]);
    static createTyped<T>(name: string, type: DesignTokenType, intendedFor?: StyleProperty | StyleProperty[]): TypedDesignToken<T>;
}

// @internal (undocumented)
export interface TypedDesignToken<T> extends DesignTokenMetadata {
}

// @internal
export const _white: Swatch;

// (No @packageDocumentation comment for this package)

```
